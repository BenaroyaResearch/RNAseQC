#' Plot RNAseq metrics
#' 
#' This function generates plots of several common metrics (total reads, % reads aligned, median CV
#' coverage) against each other for a set of libraries. It plots horizontal and vertical lines at the
#' standard QC thresholds for each metric. In addition, it plots lines at standard outlier thresholds, and
#' labels points beyond these thresholds with the library identifiers. Points are optionally colored by
#' values of a discrete or continuous variable from \code{design} specified by \code{by_var}.
#' Some options still need to be built in, e.g. plotting names of all libraries, modifying threshold values
#' for each metric, etc.
#' @param metrics matrix or data frame containing values of metrics. Should have metrics in columns and libraries in rows.
#' @param metrics.libID_col name or number of the column in \code{metrics} containing the library identifiers.
#' @param design matrix or data frame containing the library information. Should have variables in columns and libraries in rows.
#' @param design.libID_col name or number of the column in \code{design} containing the library identifiers.
#' @param threshold.percent_aligned numeric, the threshold for percent of reads aligned. Libraries with values below this threshold are flagged. Defaults to 0.8.
#' @param threshold.total_reads numeric, the threshold for total, reads, in millions. Libraries with values below this threshold are flagged. Defaults to 5.
#' @param threshold.median_cv numeric, the threshold for median CV coverage. Libraries with values above this threshold are flagged. Defaults to 1.
#' @param by_var (optional) character string or integer identifying the column in design to color points by. If not provided, points are plotted in black.
#' @param by_var_levels (optional) character vector defining the order of elements in the variable used for coloring points; this order is used for the plot legend and to match the order of colors (if provided). If not provided, levels of the variable are ordered by order of appearance in the design object.
#' @param by_var_lab (optional) string to be used as the title for the color legend.
#' @param my_cols (optional) vector of colors to use for plotting. If \code{by_var} is numeric, should have two elements, providing the start and end points for a continuous color scale (generated by \code{scale_color_gradient}). If \code{by_var} is not numeric, should be a vector with one color for each level of \code{by_var}; if the number of values supplied is less than the numer of levels in \code{by_var}, additional values are interpolated using colorRampPalette. By default, uses a range from blue to red.
#' @param na_col color to use for NA values of \code{by_var}.
#' @param point_size numeric, the size of the points to be plotted. Defaults to 1.
#' @param plot_outlier_lines logical, whether to plot the lines where points would be considered outliers, based on the Q1-1.5*IQR / Q3+1.5*IQR threshold. Defaults to TRUE.
#' @param file_prefix a character string. If provided, the function outputs pdfs of the plots, named "{file_prefix}_{plot_name}.pdf". If not provided, the function prints to a plotting window.
#' @param plotdims a numeric vector, the size (in inches) of the plotting object. Either the size of the pdfs, or the size of the plotting windows.
#' @import ggplot2
#' @export
#' @usage \code{
#' plot_metrics(metrics, metrics.libID_col="lib.id",
#'              design=NULL, design.libID_col="lib.id",
#'              threshold.percent_aligned=0.8,
#'              threshold.total_reads=5.0,
#'              threshold.median_cv=1.0,
#'              by_var=NULL, by_var_levels=NULL, by_var_lab=NULL,
#'              my_cols=c("blue","red"), na_col="grey50",
#'              point_size=1, plot_outlier_lines=TRUE,
#'              file_prefix=NULL, plotdims=c(9,9)
#'              )}
plot_metrics <- function(metrics, metrics.libID_col="lib.id",
                         design=NULL, design.libID_col="lib.id",
                         threshold.percent_aligned=0.8,
                         threshold.total_reads=5.0,
                         threshold.median_cv=1.0,
                         by_var=NULL, by_var_levels=NULL, by_var_lab=NULL,
                         my_cols=c("blue","red"), na_col="grey50",
                         point_size=1, plot_outlier_lines=TRUE,
                         file_prefix=NULL, plotdims=c(9,9)) {
  if (!((metrics.libID_col %in% colnames(metrics)) | (metrics.libID_col %in% (1:ncol(metrics)))))
    stop("Column specified by metrics.libID_col not found in metrics object.")
  if (!is.null(design) & !((design.libID_col %in% colnames(design)) |
                           (design.libID_col %in% (1:ncol(design)))))
    stop("Column specified by design.libID_col not found in design object.")
  
  metrics[,"fastq_total_reads"] <- metrics[,"fastq_total_reads"] / 1e6
  
  if (!is.null(by_var)) {plot_by_var <- TRUE
  } else plot_by_var <- FALSE
  
  file_suffix <- "pdf"; color_scale <- NULL; color_labs <- NULL
  if (plot_by_var) {
    metrics[,by_var] <-
      design[match(metrics[,metrics.libID_col], design[,design.libID_col]), by_var]
    if (!is.numeric(metrics[,by_var])) {
      if (is.null(by_var_levels)) by_var_levels <- unique(design[,by_var])
      if (length(my_cols) < length(by_var_levels))
        my_cols <- colorRampPalette(colors=my_cols)(length(by_var_levels))
      metrics[,by_var] <- factor(metrics[,by_var], levels=by_var_levels)
      color_scale <- scale_color_manual(values=my_cols)
    } else {
      color_scale <- scale_color_gradient(low=my_cols[1], high=my_cols[2], na.value=na_col)
    }
    file_suffix <- paste0("by_", by_var, ".pdf")
    
    if (!is.null(by_var_lab)) {
      color_labs <- labs(color=by_var_lab)
    } else if (is.numeric(by_var)) {
      color_labs <- labs(color=colnames(design)[by_var])
    } else {
      color_labs <- labs(color=by_var)
    }
  }
  
  if (plot_outlier_lines) {
    fastq_total_reads_quantiles <-
      c(quantile(metrics[,"fastq_total_reads"], 0.25) -
          1.5*IQR(metrics[,"fastq_total_reads"]),
        quantile(metrics[,"fastq_total_reads"], 0.75) +
          1.5*IQR(metrics[,"fastq_total_reads"]))
    mapped_reads_w_dups_quantiles <-
      c(quantile(metrics[,"mapped_reads_w_dups"], 0.25) -
          1.5*IQR(metrics[,"mapped_reads_w_dups"]),
        quantile(metrics[,"mapped_reads_w_dups"], 0.75) +
          1.5*IQR(metrics[,"mapped_reads_w_dups"]))
    median_cv_coverage_quantiles <-
      c(quantile(metrics[,"median_cv_coverage"], 0.25) -
          1.5*IQR(metrics[,"median_cv_coverage"]),
        quantile(metrics[,"median_cv_coverage"], 0.75) +
          1.5*IQR(metrics[,"median_cv_coverage"]))
  }
  
  # Plot percent aligned vs fastq total reads
  if (plot_by_var) {
    perc_aligned_vs_fastq_total_reads <- 
      ggplot(metrics,
             aes_(x=quote(fastq_total_reads), y=quote(mapped_reads_w_dups),
                 colour=as.name(by_var)))
  } else {
    perc_aligned_vs_fastq_total_reads <- 
      ggplot(metrics, aes(x=fastq_total_reads, y=mapped_reads_w_dups))
  }
  
  perc_aligned_vs_fastq_total_reads <- perc_aligned_vs_fastq_total_reads +
    geom_point(size=point_size) +
    geom_text(data=metrics[metrics[,"fastq_total_reads"] < threshold.total_reads |
                             metrics[,"mapped_reads_w_dups"] < threshold.percent_aligned,],
              mapping=aes_(label=as.name(metrics.libID_col)),
              nudge_y=-0.01, size=4, vjust=1, hjust=0.5, colour="black") +
    #               aes_(y=quote(metrics[,"mapped_reads_w_dups"]-.01),
    #                     label=as.name(metrics.libID_col)), size=4, vjust=1, hjust=0.5, colour="black") +
    labs(x = "total counts (in millions)", y = "percent alignment") +
    geom_vline(xintercept=threshold.total_reads, colour="red", size=1) +
    geom_hline(yintercept=threshold.percent_aligned, colour="red", size=1) +
    color_scale + color_labs
  
  if (plot_outlier_lines) {
    perc_aligned_vs_fastq_total_reads <- perc_aligned_vs_fastq_total_reads +
      geom_vline(xintercept=fastq_total_reads_quantiles, linetype="dotted") +
      geom_hline(yintercept=mapped_reads_w_dups_quantiles, linetype="dotted")
  }
  
  if (!is.null(file_prefix)) {pdf(file=paste(file_prefix, "perc_aligned_vs_total_count", file_suffix, sep="."),
                                  w=plotdims[1], h=plotdims[2])
  } else quartz(w=plotdims[1], h=plotdims[2])
  print(perc_aligned_vs_fastq_total_reads)
  if (!is.null(file_prefix)) dev.off()
  
  
  # Plot median_cv_coverage vs fastq_total_reads
  if (plot_by_var) {
    median_cv_coverage_vs_fastq_total_reads <- 
      ggplot(metrics,
             aes_(x=quote(fastq_total_reads), y=quote(median_cv_coverage),
                   colour=as.name(by_var)))
  } else {
    median_cv_coverage_vs_fastq_total_reads <- 
      ggplot(metrics, aes(x=fastq_total_reads, y=median_cv_coverage))
  }
  
  median_cv_coverage_vs_fastq_total_reads <- median_cv_coverage_vs_fastq_total_reads +
    geom_point(size=point_size) +
    geom_text(data=metrics[metrics[,"median_cv_coverage"] > threshold.median_cv |
                             metrics[,"fastq_total_reads"] < threshold.total_reads,],
              mapping=aes_(label=as.name(metrics.libID_col)),
              nudge_y=-0.01, size=4, vjust=1, hjust=0.5, colour="black") +
    labs(x = "total counts (in millions)", y = "median cv coverage")+
    geom_vline(xintercept=threshold.total_reads, colour="red", size=1) +
    geom_hline(yintercept=threshold.median_cv, colour="red", size=1) +
    color_scale + color_labs
  
  if (plot_outlier_lines) {
    median_cv_coverage_vs_fastq_total_reads <- median_cv_coverage_vs_fastq_total_reads +
      geom_vline(xintercept=fastq_total_reads_quantiles, linetype="dotted") +
      geom_hline(yintercept=median_cv_coverage_quantiles, linetype="dotted")
  }
  
  if (!is.null(file_prefix)) {pdf(file=paste(file_prefix, "median_cv_coverage_vs_total_count", file_suffix, sep="."),
                                  w=plotdims[1], h=plotdims[2])
  } else quartz(w=plotdims[1], h=plotdims[2])
  print(median_cv_coverage_vs_fastq_total_reads)
  if (!is.null(file_prefix)) dev.off()
  
  
  # Plot median_cv_coverage vs fastq_total_reads
  if (plot_by_var) {
    perc_aligned_vs_median_cv_coverage <- 
      ggplot(metrics,
             aes_(x=quote(median_cv_coverage), y=quote(mapped_reads_w_dups),
                  colour=as.name(by_var)))
  } else {
    perc_aligned_vs_median_cv_coverage <- 
      ggplot(metrics, aes(x=median_cv_coverage, y=mapped_reads_w_dups))
  }
  
  perc_aligned_vs_median_cv_coverage <- perc_aligned_vs_median_cv_coverage +
    geom_point(size=point_size) +
    geom_text(data=metrics[metrics[,"median_cv_coverage"] > threshold.median_cv |
                             metrics[,"mapped_reads_w_dups"] < threshold.percent_aligned,],
              mapping=aes_(label=as.name(metrics.libID_col)),
              nudge_y=-0.01, size=4, vjust=1,hjust=0.5, colour="black")+
    labs(x = "median cv coverage", y = "percent alignment") +
    geom_vline(xintercept=threshold.median_cv, colour="red", size=1) +
    geom_hline(yintercept=threshold.percent_aligned, colour="red", size=1) +
    color_scale + color_labs
  
  if (plot_outlier_lines) {
    perc_aligned_vs_median_cv_coverage <- perc_aligned_vs_median_cv_coverage +
      geom_vline(xintercept=median_cv_coverage_quantiles, linetype="dotted") +
      geom_hline(yintercept=mapped_reads_w_dups_quantiles, linetype="dotted")
  }
    
  
  if (!is.null(file_prefix)) {pdf(file=paste(file_prefix, "perc_aligned_vs_median_cv_coverage", file_suffix, sep="."),
                                  w=plotdims[1], h=plotdims[2])
  } else quartz(w=plotdims[1], h=plotdims[2])
  print(perc_aligned_vs_median_cv_coverage)
  if (!is.null(file_prefix)) dev.off()
}
